#version 460

#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_buffer_reference2 : require

#include "pto/color.glsl"
#include "pto/random.glsl"
#include "pto/ray.glsl"
#include "pto/object.glsl"
#include "pto/material.glsl"
#include "pto/sky.glsl"
#include "pto/vertex.glsl"

layout(binding = 0, set = 0)          uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D accumulation;
layout(binding = 2, set = 0, rgba8)   uniform image2D image;
layout(binding = 3, set = 0)          uniform PtProperties 
{
	mat4 view;
	mat4 projection;
	uint sampleId;
} properties;
layout(binding = 5, set = 0) uniform sampler2D sky;

layout(location = 0) rayPayloadEXT HitInfo prd;

void main() 
{
	uvec4 u = uvec4(gl_LaunchIDEXT.xy, properties.sampleId, 0);

	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + .5;// + vec2(0.5) + .5 * prng(u).xy;
	const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
	vec2 uv = inUV * 2.0 - 1.0;

	// Based on https://github.com/boksajak/referencePT/blob/master/shaders/PathTracer.hlsl#L525
	float aspect	  = properties.projection[1].y / properties.projection[0].x;
	float tanHalfFovY = 1. / properties.projection[1].y;

	vec3 rd = normalize((uv.x * properties.view[0].xyz * tanHalfFovY * aspect )
					  + (uv.y * properties.view[1].xyz * tanHalfFovY - properties.view[2].xyz ));
	vec3 ro = properties.view[3].xyz;

	const float tmin   = 0.001;
	const float tmax   = 10000.0;
	const uint bounces = 128;
	
	vec3 finalColor = vec3(0.);
	vec3 throughput = vec3(1.);
	for(uint i = 0; i < bounces; i++) 
	{
		traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, ro, tmin, rd, tmax, 0);
		if(!prd.hit && (uv.x < 0. || i == 0 ))
		{
			finalColor += throughput * sampleSky(sky, rd);
			break;
		}
		else if (!prd.hit) {
			break;
		}
		
		vec3 p = ro + rd * prd.t;
		vec3 n = prd.normal;
		Material material = prd.material;

		if(uv.x > 0.) {
			float skySamplingPdf;
			ivec2 skyBaseUv = sampleSkyLight(sky, prng(u).xy, skySamplingPdf);
			vec2 skyUv = vec2(skyBaseUv) / vec2(4096., 2048.);
			skyUv = vec2(skyUv.x * 2. * Pi, skyUv.y * Pi);

			vec3 dl = normalize(vec3(
				sin(skyUv.x) * cos(skyUv.y),
				sin(skyUv.x) * sin(skyUv.y),
				cos(skyUv)
			));

			vec3 pp = offsetRay(p, n);
			traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, pp, tmin, dl, tmax, 0);
			if(!prd.hit) 
			{
				vec3 intensity = sampleSky(sky, dl).rgb / max(1e-4, 1.);
				vec3 direct = evalLambertian(material);
				finalColor += intensity * direct;
			}

		}
		
		vec3 l;
		throughput *= sampleLambertian(material, n, prng(u).xy, l);
		ro = offsetRay(p, sign(dot(n, rd)) * n);
		rd = l;
		
		if(dot(rd, n) < 0.)
			break;
	}

    vec4 accumulatedColor = vec4(finalColor, 1.);
    // if ( properties.sampleId > 0 )
    // {
    //     const float weight                   = 1.0f / float( properties.sampleId + 1 );
    //     const vec4  previousAccumulatedColor = imageLoad(accumulation, ivec2(gl_LaunchIDEXT.xy));
    //     accumulatedColor                     = mix( previousAccumulatedColor, accumulatedColor, weight );
    // }

	imageStore(accumulation, ivec2(gl_LaunchIDEXT.xy), accumulatedColor);
	imageStore(image,		 ivec2(gl_LaunchIDEXT.xy), vec4(clamp(accumulatedColor.rgb, 0., 1.), 1.));
}
