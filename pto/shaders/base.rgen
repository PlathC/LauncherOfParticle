#version 460

#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_buffer_reference2 : require

#include "pto/color.glsl"
#include "pto/random.glsl"
#include "pto/ray.glsl"
#include "pto/object.glsl"
#include "pto/material.glsl"
#include "pto/sky.glsl"
#include "pto/vertex.glsl"

layout(binding = 0, set = 0)          uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D accumulation;
layout(binding = 2, set = 0, rgba8)   uniform image2D image;
layout(binding = 3, set = 0)          uniform PtProperties 
{
	mat4     invView;
	mat4     invProj;
	uint     sampleId;
} properties;
layout(binding = 5, set = 0) uniform sampler2D sky;

layout(location = 0) rayPayloadEXT HitInfo prd;

void main() 
{
	uint sseed = (gl_LaunchIDEXT.x + gl_LaunchIDEXT.y) ^ properties.sampleId;
	vec2 seed = gl_LaunchIDEXT.xy + lcg(sseed) + properties.sampleId;
	uvec4 u = uvec4(seed, uint(seed.x) ^ uint(seed.y), uint(seed.x) + uint(seed.y));

	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5) + .5 * prng(u).xy;
	const vec2 inUV = pixelCenter/vec2(gl_LaunchSizeEXT.xy);
	vec2 d = inUV * 2.0 - 1.0;

	vec3 ro     = (properties.invView * vec4(0,0,0,1)).xyz;
	vec4 target = properties.invProj  * vec4(d.x, d.y, 1, 1);
	vec3 rd     = (properties.invView * vec4(normalize(target.xyz), 0)).xyz;

	const float tmin   = 0.001;
	const float tmax   = 10000.0;
	const uint bounces = 32;

	vec3 finalColor = vec3(0.);
	vec3 throughput = vec3(1.);
	for(uint i = 0; i < bounces; i++) 
	{
		traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, ro, tmin, rd, tmax, 0);
		if(!prd.hit) 
		{
			finalColor += throughput * sampleSky(sky, rd);
			break;
		}

		vec3 p = ro + rd * prd.t;
		vec3 n = prd.normal;
		
		vec3 l;
		throughput *= sampleLambertian(prd.material, n, prng(u + bounces).xy, rd);
		ro = offsetRay(p, sign(dot(n, rd)) * n);

		if(length(throughput) < 1e-4 || any(isnan(throughput)) || any(isnan(rd)))
		{
			throughput = vec3(0.);
			break;
		}

		if(dot(rd, n) < 0.)
			break;
	}
	
    vec4 accumulatedColor = vec4(finalColor, 1.);
    if ( properties.sampleId > 0 )
    {
        const float weight                   = 1. / float( properties.sampleId + 1 );
        const vec4  previousAccumulatedColor = imageLoad(accumulation, ivec2(gl_LaunchIDEXT.xy));
        accumulatedColor                     = mix( previousAccumulatedColor, accumulatedColor, weight );
    }

	imageStore(accumulation, ivec2(gl_LaunchIDEXT.xy), accumulatedColor);
	imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(ACESFilm(clamp(accumulatedColor.rgb, 0., 1.)), 1.));
}
