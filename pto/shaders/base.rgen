#version 460

#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_buffer_reference2 : require

#include "pto/color.glsl"
#include "pto/environment.glsl"
#include "pto/image.glsl"
#include "pto/material.glsl"
#include "pto/object.glsl"
#include "pto/random.glsl"
#include "pto/ray.glsl"
#include "pto/sampling.glsl"
#include "pto/vertex.glsl"

layout(binding = 0, set = 0)          uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba32f) uniform image2D accumulation;
layout(binding = 2, set = 0, rgba8)   uniform image2D image;
layout(binding = 3, set = 0)          uniform PtProperties 
{
	mat4 view;
	mat4 projection;
	uint sampleId;
	uint skySamplingSize;
} properties;
layout(binding = 5, set = 0) uniform sampler2D sky;
layout(binding = 6, set = 0) uniform sampler2D skySampling;

layout(location = 0) rayPayloadEXT HitInfo prd;

void main() 
{
	uvec4 u = uvec4( gl_LaunchIDEXT.x, gl_LaunchIDEXT.y, properties.sampleId, 0 );

	const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + vec2(0.5) + .5 * prng(u).xy;
	const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
	vec2 uv = inUV * 2.0 - 1.0;

	// Based on https://github.com/boksajak/referencePT/blob/master/shaders/PathTracer.hlsl#L525
	float aspect	  = properties.projection[1].y / properties.projection[0].x;
	float tanHalfFovY = 1. / properties.projection[1].y;
	
	vec3 rd = normalize((uv.x * properties.view[0].xyz * tanHalfFovY * aspect )
					  + (uv.y * properties.view[1].xyz * tanHalfFovY - properties.view[2].xyz ));
	vec3 ro = properties.view[3].xyz;

	const float tmin   = 0.001;
	const float tmax   = 10000.0;
	const uint bounces = 4;

	vec3 finalColor = vec3(0.);
	vec3 throughput = vec3(1.);

	if(abs(uv.x) > .005) 
	{
		for(uint i = 0; i < bounces; i++) 
		{
			traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, ro, tmin, rd, tmax, 0);
			if(!prd.hit && (uv.x < 0. || i == 0 ))
			{
				finalColor += throughput * getEnvironment(sky, rd);
				break;
			}
			else if (!prd.hit) 
			{
				break;
			}
		
			vec3 p = ro + rd * prd.t;
			vec3 n = prd.normal;

			Material material = prd.material;
			if( uv.x >= 0. ) 
			{
				float lightPdf;
				const vec3 wi = sampleEnvironment( skySampling, properties.skySamplingSize, prng(u).xy, lightPdf );
				if( dot( wi, n ) > 0. && lightPdf > 0. ) 
				{
					vec3 pp = offsetRay( p, n );
					traceRayEXT( topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, pp, tmin, wi, tmax, 0 );
					if( !prd.hit ) 
					{
						vec3 intensity  = getEnvironment( sky, wi ).rgb;
						vec3 direct     = evalLambertian( material );
						finalColor     += ( throughput * direct * intensity / lightPdf ) * dot( wi, n );
					}
				}
			}
		
			vec3 l;
			throughput *= sampleLambertian(material, n, prng(u).xy, l);
			ro = offsetRay(p, sign(dot(n, rd)) * n);
			rd = l;
		
			if(dot(rd, n) < 0.)
				break;
		}
	}

    vec4 accumulatedColor		  = vec4( finalColor, 1. );
	vec4 previousAccumulatedColor = properties.sampleId > 0 ? imageLoad( accumulation, ivec2(gl_LaunchIDEXT.xy) ) : vec4(0.);
	previousAccumulatedColor	 += accumulatedColor;
	
	imageStore(accumulation, ivec2(gl_LaunchIDEXT.xy), previousAccumulatedColor);

	vec3 displayColor = clamp(previousAccumulatedColor.rgb / float(previousAccumulatedColor.w), 0., 1.);
	imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(ACESFilm(displayColor), 1.));
}
